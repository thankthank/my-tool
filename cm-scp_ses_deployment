#!/bin/bash
##########################################
## Please read this before deployment.
## Locate the airgap tarbal and this script together in a directory where you want to put these file. 
## And run the this deployment script. Don't remove deployment_script.

## This script SCPs the bach script generated by this script to target hosts and run the generated script on target hosts.
## So this script has a framework called SCP_RUN Framework. I commented '## SCP_RUN Framework Begins/Ends ##' for the framework respectively.

## Normally, users only changes values and functions between '## USER jobs Begins/Ends ##'
##########################################

######################
## USER jobs Begins ##
######################
## Variables below need to be adapted to the deployment environment.
## IP addresses which are configured on target nodes. 
MGMT_IP="192.168.37.75"
MON_IP=(192.168.37.76 192.168.37.77 192.168.37.78)
OSD_IP=(192.168.37.76 192.168.37.77 192.168.37.78)
## Network configuration variables. Hostnames you want to configure on target nodes. Even if you already configured hostname, put the configured hostnames here and skip the hostname configuration function.
MGMT="ses-admin"
DOMAIN="suse.su" # DOMAIN name for this lab. 
MGMT_FQDN="$MGMT.$DOMAIN" #This is also FQDN of registry
MON=(ses2 ses3 ses4)
OSD=(ses2 ses3 ses4)

## Functionis Configuration variables : Variables which are used by functions
DNS_SERVER="168.126.63.1" # DNS resolve configuration
GATEWAY="192.168.37.254" # Network gateway
NTP_CLIENT_NET="192.168.0.0/16" # NTP client
######################
## USER jobs Ends   ##
######################


## SCP_RUN Framework Begins  ##
## The file name of Tar ball which need to be deployed.
TAR_BALL_AIRGAPPED="ses6_airgap_200309.tar" 

## Default Configuration of framework variables. Modify this when you need to change Framework. 
TAR_DEPLOYED_DIR="/root" # The location where airgap.tar file extracted.
LOCAL_REPO_DIR="$TAR_DEPLOYED_DIR/local_repo" 
SCRIPT_NAME="cm-scp_ses_deployment" # This script name
MY_TOOL_INSTALLED_DIR="/usr/local/bin"
Files="temp_$(date +%y%m%d%H%M%S).sh"
Logfile="/var/log/${SCRIPT_NAME}_$(date +%y%m%d).log"
if [[ ! -e $Logfile ]];then touch $Logfile;fi;
SCP_RUN_Target_dir='/root'

## Hostname and IP aggregation
HOSTNAME_TOTAL=()
HOSTNAME_TOTAL[0]=$MGMT
j=${#HOSTNAME_TOTAL[@]};for i in "${MON[@]}";do HOSTNAME_TOTAL[$j]=$i; ((j=j+1));done;
j=${#HOSTNAME_TOTAL[@]};for i in "${OSD[@]}";do HOSTNAME_TOTAL[$j]=$i; ((j=j+1));done;
IP_TOTAL=()
IP_TOTAL[0]=$MGMT_IP
j=${#IP_TOTAL[@]};for i in "${MON_IP[@]}";do IP_TOTAL[$j]=$i; ((j=j+1));done;
j=${#IP_TOTAL[@]};for i in "${OSD_IP[@]}";do IP_TOTAL[$j]=$i; ((j=j+1));done;
SES_TOTAL=()
j=${#SES_TOTAL[@]};for i in "${MON[@]}";do SES_TOTAL[$j]=$i; ((j=j+1));done;
j=${#SES_TOTAL[@]};for i in "${OSD[@]}";do SES_TOTAL[$j]=$i; ((j=j+1));done;
SES_IP_TOTAL=()
j=${#SES_IP_TOTAL[@]};for i in "${MON_IP[@]}";do SES_IP_TOTAL[$j]=$i; ((j=j+1));done;
j=${#SES_IP_TOTAL[@]};for i in "${OSD_IP[@]}";do SES_IP_TOTAL[$j]=$i; ((j=j+1));done;
HOSTS=();
#echo "HOSTNAME_TOTAL : " ${#HOSTNAME_TOTAL[@]}" :" ${HOSTNAME_TOTAL[@]}

# Temporary configuration
HOSTS_TEMP=(ses-admin) # Array for temporary run

## Framework Function variables
PUBLIC_KEY=$(cat $LOCAL_REPO_DIR/keys/id_rsa.pub)
PRIVATE_KEY=$(cat $LOCAL_REPO_DIR/keys/id_rsa)

## App Function variables
#CACERT=$(cat $LOCAL_REPO_DIR/cert/natgw_cert/cacert.pem)

## The file, which will be excuited on targets, generation begins #
# It includes libraries
cat $LOCAL_REPO_DIR/my-tool/lib/*.sh > /tmp/$Files;

cat << EOT >> /tmp/$Files
MON=(${MON[@]} )
MON_IP=(${MON_IP[@]} )
OSD=(${OSD[@]})
OSD_IP=(${OSD_IP[@]})
HOSTNAME_TOTAL=(${HOSTNAME_TOTAL[@]})
IP_TOTAL=(${IP_TOTAL[@]})
SES_TOTAL=(${SES_TOTAL[@]})
SES_IP_TOTAL=(${SES_IP_TOTAL[@]})

# Libraries which use Framework values
Debug () {
echo;echo;echo;echo;
echo '(('CMD'))' "\$@" | tee -a $Logfile
while true;do echo -n "Input 'y' and 'Enter' to continue this command.....";read INPUT; if [[ \$INPUT == "y" ]];then  break;fi;done
echo '(('OUTPUT-Started:\$(date +%FT%H:%M:%S)'))'
"\$@" | tee -a $Logfile
echo '(('OUTPUT-Done:\$(date +%FT%H:%M:%S)'))'
}

Debug_print () {
echo;echo;echo;echo;
# Only print Command and no OUTPUT. It will be used commands which include terminator such as ;, >, ||
# Use single quote in Single quote
# Debug_print $'echo \'ls -al\' | grep tt '
echo '(('CMD_print'))' "\$@" | tee -a $Logfile
while true;do echo -n "Input 'y' and 'Enter' to continue this command.....";read INPUT; if [[ \$INPUT == "y" ]];then  break;fi;done
echo '(('OUTPUT:\$(date +%FT%H:%M:%S)'))'
}


TempSshAccessForDeployment_on_All () {

# SSH key setting
mkdir -p ~/.ssh;chmod 700 ~/.ssh;
echo "$PUBLIC_KEY" > ~/.ssh/id_rsa.pub;
echo "$PRIVATE_KEY" > ~/.ssh/id_rsa;
echo "$PUBLIC_KEY" > ~/.ssh/authorized_keys;

chmod 644 ~/.ssh/authorized_keys
chmod 600 ~/.ssh/id_rsa
chmod 644 ~/.ssh/id_rsa.pub


}

SshKnownhost_on_Management () {


j=\${#HOSTNAME_TOTAL[@]};
#for i in {0..\$j} ;
for (( i=0; i < \$j; i++ ));
do
	#Debug_print \$'ssh-keyscan -t ecdsa-sha2-nistp256 \$IP_TOTAL[\$i] >> ~/.ssh/known_hosts'
	ssh-keyscan -t ecdsa-sha2-nistp256 \${IP_TOTAL[\$i]} >> ~/.ssh/known_hosts

done;


}

AirgappedTarBallDeployment_on_Management () {

# Untar the tarball
Debug tar xvf $TAR_BALL_AIRGAPPED -C $TAR_DEPLOYED_DIR/
# Delete the tar ball to save space
Debug rm -f $TAR_BALL_AIRGAPPED
# Create symbolic link for deployment script.
Debug ln -sf $PWD/$SCRIPT_NAME $MY_TOOL_INSTALLED_DIR/$SCRIPT_NAME


}

DeployRepositories_on_Management () {

cd $LOCAL_REPO_DIR
./deploy_repos.sh


}

RegisterRepositories_on_SES () {

scp -o StrictHostKeyChecking=no $MGMT_IP:$LOCAL_REPO_DIR/register_client.sh ~/
Debug ./register_client.sh $MGMT_IP

}

MyToolDeployment_on_Management () {

for i in cm- cm-scp;
do ln -sf $LOCAL_REPO_DIR/my-tool/\$i $MY_TOOL_INSTALLED_DIR/\$i
done;

## Hostlist generation
echo "## Ceph Nodes" > ~/hostlist;
for i in ${MON_IP[@]};
do
	echo \$i >> ~/hostlist	
done;
echo "## MGMT Nodes" >> ~/hostlist;
echo $MGMT_IP >> ~/hostlist;

}

## SCP_RUN Framework Ends    ##

## workload function started from here
## System related functions
EtcHosts_on_All () {

j=0;for i in "\${HOSTNAME_TOTAL[@]}"; do

# hostnames match but ip address is different
cat /etc/hosts | awk -v V1="\${IP_TOTAL[\$j]}" -v V2="\${HOSTNAME_TOTAL[\$j]}" \$'{
split(\$2,a,".")
if(a[1]==V2 && \$1!=V1) print "sed -i \'s/"\$0"/#"\$0"/g\' /etc/hosts"
}'|bash 
# if there is no hostname
cat /etc/hosts | grep -v ^# |  grep -w \${HOSTNAME_TOTAL[\$j]} ||echo "\${IP_TOTAL[\$j]} \$i.$DOMAIN \$i" >> /etc/hosts

(( j=j+1 ));done

}

Basic_Network_on_All () {
##disable ipv6 for all
echo "net.ipv6.conf.all.disable_ipv6 = 1" > /etc/sysctl.d/ipv6.conf

##resolv.conf for all
Debug sed -i 's/NETCONFIG_DNS_STATIC_SEARCHLIST=""/NETCONFIG_DNS_STATIC_SEARCHLIST="$DOMAIN"/g' /etc/sysconfig/network/config
Debug sed -i 's/NETCONFIG_DNS_STATIC_SERVERS=""/NETCONFIG_DNS_STATIC_SERVERS="$DNS_SERVER"/g' /etc/sysconfig/network/config

## Default route
Debug_print $'echo \'default $GATEWAY - -\' > /etc/sysconfig/network/routes'
echo 'default $GATEWAY - -' > /etc/sysconfig/network/routes
}

Basic_Configuration_on_All () {
## Install packages for all
Debug zypper --non-interactive in -t pattern enhanced_base 
Debug zypper --non-interactive in sudo wget
Debug zypper --non-interactive up --no-recommends kernel-default
## Install the package below depending on situation
#Debug zypper --non-interactive in -t pattern  yast2_basis

## Insert CA cert
#cat << EOF  >  /etc/pki/trust/anchors/cacert.pem
#$CACERT
#EOF
## The command below will update /etc/ssl/ca-buldle.pem
#Debug update-ca-certificates;

## CPU and Memory account in systemd for all
cat /etc/systemd/system.conf | grep ^'DefaultCPUAccounting=yes' || echo 'DefaultCPUAccounting=yes' >> /etc/systemd/system.conf
cat /etc/systemd/system.conf | grep ^'DefaultMemoryAccounting=yes' || echo 'DefaultMemoryAccounting=yes' >> /etc/systemd/system.conf 

## Uniqueue Machine ID for all
Debug rm -f /etc/machine-id
Debug dbus-uuidgen --ensure
Debug systemd-machine-id-setup
Debug systemctl restart systemd-journald

## Firewall
Debug systemctl stop firewalld.service
Debug systemctl disable firewalld.service

# Need to reboot or similar job for k8s to recognize Cert
sync;
sync;
}


NetworkInterfaceAndHostname_on_All () {

# Configure hostname
IP_HERE=\$(ip addr show dev eth0 | grep global | head -1 | awk -F/ '{print \$1}' | awk '{print \$2}')

(( j=0 ))
for i in \${IP_TOTAL[@]};
do
	#echo i : \$i;echo IP_HERE : \$IP_HERE;
	if [[ \$IP_HERE == \$i  ]];then
	#Debug_print $'echo \${HOSTNAME_TOTAL[\$j]} > /etc/hostname'
	echo \${HOSTNAME_TOTAL[\$j]} > /etc/hostname
	hostname \${HOSTNAME_TOTAL[\$j]}
	fi;
	((j=j+1))	
done

# Configure IP
cat << EOF > /etc/sysconfig/network/ifcfg-eth0
BOOTPROTO='static'
BROADCAST=''
ETHTOOL_OPTIONS=''
IPADDR='\$IP_HERE/24'
MTU=''
NAME=''
NETMASK=''
NETWORK=''
REMOTE_IPADDR=''
STARTMODE='auto'
DHCLIENT_SET_DEFAULT_ROUTE='yes'
EOF
Debug systemctl restart network

}

Chrony_for_ntp_server_on_Management () {
Debug sed -i 's/! pool pool.ntp.org iburst/#! pool pool.ntp.org iburst/g' /etc/chrony.conf
Debug sed -i 's+#allow 192.168.0.0/16+allow $NTP_CLIENT_NET+g' /etc/chrony.conf
Debug sed -i 's/#local stratum 10/local stratum 10/g' /etc/chrony.conf
Debug systemctl restart chronyd
Debug systemctl enable chronyd
}

Chrony_for_ntp_client_on_SES () {
sed -i 's/! pool pool.ntp.org iburst/#! pool pool.ntp.org iburst/g' /etc/chrony.conf
cat /etc/chrony.conf | grep 'server $MGMT_FQDN iburst' || echo 'server $MGMT_FQDN iburst' >> /etc/chrony.conf
systemctl restart chronyd
systemctl enable chronyd
}

SMTPsender_on_Management() {

Debug zypper --non-interactive in postfix
Debug sed -i "s+#mynetworks = 168.100.189.0/28, 127.0.0.0/8+mynetworks = 192.168.0.0/16, 127.0.0.0/8+g" /etc/postfix/main.cf
Debug sed -i "s+inet_interfaces = localhost+inet_interfaces = all+g" /etc/postfix/main.cf
Debug systemctl enable postfix
Debug systemctl restart postfix

echo "Port 25 opened for SMTP sender"

}

## App related functions

SaltMaster_on_Management () {

Debug zypper --non-interactive in -y salt-master;
Debug systemctl enable salt-master;
Debug systemctl start salt-master;

}

SaltMinion_on_All () {

zypper --non-interactive in salt-minion;
echo 'master: $MGMT_FQDN' > /etc/salt/minion.d/master.conf
systemctl restart salt-minion;
systemctl enable salt-minion;

}

SaltKeyGrain_on_Management() {

Debug salt-key -F
Debug salt-key --accept-all

## This configuration disappears after reboot.
Debug salt '*' grains.append deepsea default
Debug salt -G 'deepsea:*' test.ping

}


Zapdisk_on_All () {

echo "Implement zap disk"

}

DeepseaDeployment_on_Management() {

zypper --non-interactive in deepsea
# Target for deepsea
Debug cat /srv/pillar/ceph/deepsea_minions.sls
cat << EOF > /srv/pillar/ceph/deepsea_minions.sls
# Choose all minions
deepsea_minions: '*'
# Choose minions with a deepsea grain
#deepsea_minions: 'G@deepsea:*'
EOF
}

UpdateNodes_on_All () {
Debug zypper --non-interactive up
Debug zypper --non-interactive up
}

Stage0_on_Management () {

Debug echo "Run deepsea monitor in other window"
Debug salt-run state.orch ceph.stage.0
## 'deepsea stage run' is not working in this framework.
#deepsea stage run ceph.stage.0
}

Stage1_on_Management () {

#Debug echo "Run deepsea monitor in other window"
#Debug salt-run state.orch ceph.stage.1

Debug cp /usr/share/doc/packages/deepsea/examples/policy* /srv/pillar/ceph/proposals/
echo;echo "/srv/pillar/ceph/proposals/policy.cfg is created"
cat << EOF > /srv/pillar/ceph/proposals/policy.cfg
## Cluster Assignment
cluster-ceph/cluster/*.sls

## Roles
# ADMIN
role-master/cluster/ses-admin*.sls
role-admin/cluster/ses-admin*.sls

# Monitoring
role-prometheus/cluster/ses-admin*.sls
role-grafana/cluster/ses-admin*.sls

# MON
role-mon/cluster/ses[234]*.sls

# MGR (mgrs are usually colocated with mons)
role-mgr/cluster/ses[234]*.sls

# MDS
#role-mds/cluster/mds*.sls

# IGW
#role-igw/cluster/igw*.sls

# RGW
#role-rgw/cluster/rgw*.sls

# NFS
#role-ganesha/cluster/ganesha*.sls

# COMMON
config/stack/default/global.yml
config/stack/default/ceph/cluster.yml

# Storage

role-storage/cluster/ses[234]*.sls
role-storage/cluster/ses-admin*.sls
EOF

# Public and Cluster Network configuration
TEXT=\$(cat /srv/pillar/ceph/proposals/config/stack/default/ceph/cluster.yml | grep -v cluster_network | grep -v public_network)
echo "\${TEXT}" > /srv/pillar/ceph/proposals/config/stack/default/ceph/cluster.yml
TEXT=""
cat << EOF >> /srv/pillar/ceph/proposals/config/stack/default/ceph/cluster.yml
cluster_network: 192.168.37.0/24
public_network: 192.168.37.0/24
EOF

}

Stage2_on_Management () {

Debug salt-run state.orch ceph.stage.2 

## disable subvolume valication
echo 'subvolume_init: disabled' >> /srv/pillar/ceph/stack/global.yml
Debug salt '*' saltutil.pillar_refresh

echo;echo Check pillar data
Debug salt '*' pillar.items

}

Stage3_on_Management () {

Debug salt-run state.orch ceph.stage.3 
Debug ceph -s

}

Stage4_on_Management () {

Debug salt-run state.orch ceph.stage.4
Debug ceph -s

}
Stage5_on_Management () {

Debug salt-run state.orch ceph.stage.5 
Debug ceph -s

}


Test_on_Management () {
Debug echo "test"
Debug_print echo "print"
echo "print"
}

Test_on_All () {
Debug echo "test"
Debug_print echo "print"
echo "print"
}

## SCP_RUN Framework Begins  ##
## Do not Remove Below '## Here to run'. This will be used for target setting
## Here to run
## SCP_RUN Framework Ends    ##

######################
## USER jobs Begins ##
######################

## Deployment tool preparation functions
#AirgappedTarBallDeployment_on_Management
#TempSshAccessForDeployment_on_All
#DeployRepositories_on_Management
#RegisterRepositories_on_SES
#SshKnownhost_on_Management
#MyToolDeployment_on_Management

## Network and System Configuation functions
#EtcHosts_on_All
#Basic_Network_on_All
#Basic_Configuration_on_All

########################################
### Manual tasks below
## 1. Configure for Hostname and static network (IP, Subnet MASK) using Yast or networkfile for each node.
## 2. Reboot all nodes
##
## If you use the network interface, eth0, you can run the function below to configure static network and hostname.
#NetworkInterfaceAndHostname_on_All

#Chrony_for_ntp_server_on_Management
#Chrony_for_ntp_client_on_SES


## SES deployment
#SaltMaster_on_Management
#SaltMinion_on_All
#UpdateNodes_on_All
#Zapdisk_on_All
## Reboot nodes
#SaltKeyGrain_on_Management
#DeepseaDeployment_on_Management

## Preparation and Update stage
#Stage0_on_Management

## Discovery Stage
#Stage1_on_Management

## Configuration Stage
#Stage2_on_Management

## Deployment Stage
#Stage3_on_Management

## Additional deployment stage
#Stage4_on_Management

## Removal stage
#Stage5_on_Management

## Etc
#Test_on_All
#Test_on_Management

######################
## USER jobs Ends   ##
######################


## SCP_RUN Framework Begins  ##
## Do not Remove Below '## Here done'. This will be used for target setting
## Here done
EOT
## The file, which will be excuited on targets, generation ends   ##

##################################################
## The Essential part of The SCP_RUN Framework  ##
##################################################
## Framework Target setting (= Mapping hostname array to SCP_RUN Target)
# It looks for targets on which the script will run using function names
# espacially, SCP_RUN_Target name will be reside at the end of function name after '_'. e.g. this_is_function_Management
# Regarding SCP_RUN_Target and hoatname array mapping, two parts with "## mapping" below need to be configured.
rm -f /tmp/${SCRIPT_NAME}_HosSe.t;touch /tmp/${SCRIPT_NAME}_HosSe.t;
rm -f /tmp/${SCRIPT_NAME}_function.t; touch /tmp/${SCRIPT_NAME}_function.t;
# Find deployment script in the current directory. If it is not in current directory, find the script in ${MY_TOOL_INSTALLED_DIR}
if [[ -e ${PWD}/${SCRIPT_NAME} ]]; then SCRIPT_NAME_FOUND="${PWD}/${SCRIPT_NAME}";else SCRIPT_NAME_FOUND="${MY_TOOL_INSTALLED_DIR}/${SCRIPT_NAME}";fi;
awk -F_ -v VHOS="/tmp/${SCRIPT_NAME}_HosSe.t" -v VFUN="/tmp/${SCRIPT_NAME}_function.t;"  $'
	BEGIN{VEXE=0};{
	if($1=="## Here to run") {VEXE=1;};
	## mapping
	if(VEXE==1 && ($0~/Management *$/ || $0~/All *$/ || $0~/SES *$/ || $0~/Temp *$/  ) && $1!~/^ *#/) {
		print "BA="$0";echo ${BA##*_} >> "VHOS;  
		print "BA="$0";echo ${BA} >> "VFUN;  
	};
	if($1=="## Here done") {VEXE=0;}
	};
' ${SCRIPT_NAME_FOUND}  | bash
SCP_RUN_Target_Num=$(awk '!a[$0]++' /tmp/${SCRIPT_NAME}_HosSe.t | wc -l) 
SCP_RUN_TARGET=$(awk '!a[$0]++' /tmp/${SCRIPT_NAME}_HosSe.t) 
SCP_RUN_FUNCTIONS=$(cat /tmp/${SCRIPT_NAME}_function.t)
NUM=$SCP_RUN_Target_Num

# Set up SCP_RUN_TARGET with the enabled SCP_RUN_TARGET above
# This part will be changed depending on script. Here, you define SCP_RUN_TARGET!
HOSTS_PRE=();
if (( NUM > 1 ));then  echo "More than one SCP RUN Targets as follows. Please speckfy only one type of target!";echo $SCP_RUN_TARGET;  exit 1;
else
	## mapping
	if [[ $SCP_RUN_TARGET == "Management" ]]; then HOSTS_PRE[0]=$MGMT_IP;           fi;
	if [[ $SCP_RUN_TARGET == "All" ]]; then HOSTS_PRE=("${IP_TOTAL[@]}");  fi;
	if [[ $SCP_RUN_TARGET == "SES" ]]; then HOSTS_PRE=("${SES_IP_TOTAL[@]}");   fi; 
	if [[ $SCP_RUN_TARGET == "Temp" ]]; then HOSTS_PRE=("${HOSTS_TEMP[@]}");     fi; 
fi;
rm -f /tmp/${SCRIPT_NAME}_HosSe.t;
rm -f /tmp/${SCRIPT_NAME}_function.t;

#Remove duplication in HOSTS_PRE array
HOSTS=();
for i in "${HOSTS_PRE[@]}";do 
	(( non=0 ));for ii in "${HOSTS[@]}";do
		if [[ $ii != $i  ]]; then (( non=non+1 ));fi
	done
	HOSTS_COUNT=${#HOSTS[@]}
	if (( non == HOSTS_COUNT )); then HOSTS[$HOSTS_COUNT]=$i;fi
done


##Script will be SCPed and run in the remote hosts
echo;
echo "============================================================"
echo "The functions will run on the target hosts";
echo;
echo "Functions : "$SCP_RUN_FUNCTIONS
echo 'Target Hosts: '${HOSTS[@]}
echo "============================================================"
while true;do echo -n "Input 'y' and 'Enter' to continue.....";read INPUT; if [[ $INPUT == "y" ]];then  break;fi;done
for i in "${HOSTS[@]}";
do

        echo;echo "================CMD_Started on $i==================";
        scp -o StrictHostKeyChecking=no  /tmp/$Files $i:$SCP_RUN_Target_dir;
	ssh -o StrictHostKeyChecking=no $i bash ${SCP_RUN_Target_dir}/${Files}
	ssh -o StrictHostKeyChecking=no $i rm -f ${SCP_RUN_Target_dir}/${Files}
	echo "================CMD_Done==================";
        echo;

done;

rm -f /tmp/$Files;
echo "================ALL_Done==================";
## SCP_RUN Framework Ends    ##
